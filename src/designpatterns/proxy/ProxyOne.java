package designpatterns.proxy;

/**
 * 代理模式的动机：
 * 在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到
 * 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。
 * 
 * 通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即
 * 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。
 * 
 * 代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。
 * 
 * 代理分为静态代理和动态代理，动态代理又分为JDK动态代理和CGlib动态代理
 * 静态代理：代理类是在编译时就实现好的。也就是说Java完成编译后代理类就是一个实际的class文件。
 * 动态代理：代理类是在运行时生成的，也就是说Java在编译完成后并没有生成实际的class文件，而是在运行时动态生成的类字节码，并加载到JVM中。
 * 
 * 静态代理的缺点：1、当有很多代理方法时，会产生许多的重复代码。此外如果委托类接口增加方法时，所有的代理类也要实现此方法，增加了维护代码的难度。
 *             而解决这两个问题的最好做法是可以通过一个代理类完成所有的代理功能，这时就要使用动态代理啦。
 *         	   2、如果被代理类类型不同，而我们代理类额外添加的逻辑又是一样的，那么针对不同类型的被代理类，我们就要创建成千上百的代理类，显然这是不合适的。
 */
public class ProxyOne {

}
